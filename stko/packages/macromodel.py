"""
MacroModel Software
===================

Contains the base classes for the MacroModel software.

"""

import os
import logging
import subprocess as sp
import re
import time
import gzip

logger = logging.getLogger(__name__)


class MacroModelConversionError(Exception):
    ...


class MacroModelPathError(Exception):
    ...


class MacroModelForceFieldError(Exception):
    ...


class MacroModelOptimizationError(Exception):
    ...


class MacroModelLewisStructureError(Exception):
    ...


class MacroModelInputError(Exception):
    ...


class MacroModel:
    """
    Base class for MacroModel software.

    """

    def __init__(
        self,
        macromodel_path,
        output_dir,
        timeout,
    ):
        """
        Initialize a :class:`MacroModel` instance.

        Parameters
        ----------
        macromodel_path : :class:`str`
            The full path of the Schrodinger suite within the user's
            machine. For example, on a Linux machine this may be
            something like ``'/opt/schrodinger2017-2'``.

        output_dir : :class:`str`
            The name of the directory into which files generated during
            the optimization are written, if ``None`` then
            :func:`uuid.uuid4` is used.

        timeout : :class:`float`
            The amount in seconds the optimization is allowed to run
            before being terminated. ``None`` means there is no
            timeout.

        """

        self._macromodel_path = macromodel_path
        self._output_dir = output_dir
        self._timeout = timeout

    def _run_bmin(self, mol, run_name):
        """
        Run an optimization using bmin.

        Parameters
        ----------
        mol : :class:`.Molecule`
            The molecule being optimized.

        run_name : :class:`str`
            The name of the run. The files generated by this run
            will have this name.

        Returns
        -------
        None : :class:`NoneType`

        Raises
        ------
        :class:`MacroModelOptimizationError`
            If the optimization failed for some unspecified.

        :class:`MacroModelForceFieldError`
            If the force field could not be used with the molecule.

        :class:`MacroModelLewisStructureError`
            If Lewis structure of the molecule had issues.

        :class:`MacroModelPathError`
            If an invalid MacroModel path is being used.

        """

        logger.info(f'Running bmin on "{mol}".')

        # To run MacroModel a command is issued to the console via
        # ``subprocess.Popen``. The command is the full path of the
        # ``bmin`` program. ``bmin`` is located in the Schrodinger
        # installation folder.
        log_file = f'{run_name}.log'
        opt_app = os.path.join(self._macromodel_path, 'bmin')
        # The first member of the list is the command, the following
        # ones are any additional arguments.

        opt_cmd = [opt_app, run_name, '-WAIT', '-LOCAL']

        incomplete = True
        while incomplete:
            process = sp.Popen(
                opt_cmd,
                stdout=sp.PIPE,
                stderr=sp.STDOUT,
                universal_newlines=True
            )
            try:
                output, _ = process.communicate(timeout=self._timeout)

            except sp.TimeoutExpired:
                logger.warning(
                    'Minimization took too long and was terminated '
                    f'by force on "{mol}".'
                )
                self._kill_bmin(mol)
                output = ''

            logger.debug(
                f'Output of bmin on "{mol}" was: {output}.'
            )

            with open(log_file, 'r') as log:
                log_content = log.read()

            # Check the log for error reports.
            error1 = 'termination due to error condition           21-'
            if error1 in log_content:
                raise MacroModelOptimizationError(
                    'bmin crashed. See log file.'
                )

            error2 = 'FATAL do_nosort_typing: NO MATCH found for atom '
            if error2 in log_content:
                raise MacroModelForceFieldError(
                    'The log implies the force field failed.'
                )

            error3 = (
                'FATAL gen_lewis_structure(): '
                'could not find best Lewis structure'
            )
            error4 = (
                'skipping input structure  '
                'due to forcefield interaction errors'
            )
            if error3 in log_content and error4 in log_content:
                raise MacroModelLewisStructureError(
                    'bmin failed due to poor Lewis structure.'
                )

            if 'MDYN error encountered' in log_content:
                raise MacroModelOptimizationError(
                    'MD error during optimization.'
                )

            # If optimization fails because a wrong Schrodinger path
            # was given, raise.
            if 'The system cannot find the path specified' in output:
                raise MacroModelPathError(
                    'Invalid Schrodinger path given to bmin.'
                )

            # If optimization fails because the license is not found,
            # rerun the function.
            if self._license_found(run_name, output, mol):
                incomplete = False

        # Make sure the .maegz file created by the optimization is
        # present.
        maegz = f'{run_name}-out.maegz'
        self._wait_for_file(maegz)
        if (
            not os.path.exists(log_file) or
            not os.path.exists(maegz) or
            log_content == ''
        ):
            raise MacroModelOptimizationError(
                'The .log and/or .maegz files were not created'
                ' correctly.'
            )

    def _kill_bmin(self, mol, run_name):
        """
        Kill bmin.

        Parameters
        ----------
        mol : :class:`.Molecule`
            The molecule being optimized.

        run_name : :class:`str`
            The name of the run. The files generated by this run will
            have this name.

        Returns
        -------
        None : :class:`NoneType`

        """

        name = re.split(r'\\|/', run_name)[-1]
        app = os.path.join(self._macromodel_path, 'jobcontrol')
        cmd = [app, '-stop', name]

        incomplete = True
        while incomplete:
            out = sp.run(
                cmd,
                stdout=sp.PIPE,
                stderr=sp.STDOUT,
                universal_newlines=True
            )

            # Keep re-running the function until license is found.
            if self._license_found(run_name, out.stdout):
                incomplete = False

        # This loop causes the function to wait until the job has been
        # killed via job control. This means the output files will have
        # been written by the time the function exits. Essentially the
        # loop continues until the job is no longer found by
        # "./jobcontrol -list"
        cmd = [app, '-list']
        output = name
        start = time.time()
        while name in output:
            output = sp.run(
                cmd,
                stdout=sp.PIPE,
                stderr=sp.STDOUT,
                universal_newlines=True
            ).stdout
            if time.time() - start > 600:
                break

    def _license_found(self, run_name, output, mol=None):
        """
        Check to see if minimization failed due to a missing license.

        The user can be notified of this in one of two ways. Sometimes
        the output of the submission contains the message informing
        that the license was not found and in other cases it will be
        the log file. This function checks both of these sources for
        this message.

        Parameters
        ----------
        run_name : :class:`str`
            The name of the run. The files generated by this run will
            have this name.

        output : :class:`str`
            The output from submitting the minimization of the
            structure to bmin.

        mol : :class:`.Molecule`, optional
            The molecule being optimized. If the ``.log`` file is not
            to be checked, the default ``None`` should be used.

        Returns
        -------
        :class:`bool`
            ``True`` if the license was found. ``False`` if the
            minimization did not occur due to a missing license.

        """

        if 'Could not check out a license for mmlibs' in output:
            return False
        if mol is None:
            return True

        # To check if the log file mentions a missing license file open
        # the log file and scan for the appropriate string.

        # Check if the file exists first. If not, this is often means
        # the calculation must be redone so return False anyway.
        with open(f'{run_name}.log', 'r') as log_file:
            log_file = log_file.read()

        if 'Could not check out a license for mmlibs' in log_file:
            return False

        return True

    @staticmethod
    def _get_com_line(
        arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9
    ):
        return (
            f' {arg1:<5}{arg2:>7}{arg3:>7}'
            f'{arg4:>7}{arg5:>7}{arg6:>11.4f}'
            f'{arg7:>11.4f}{arg8:>11.4f}{arg9:>11.4f}'
        )

    def _run_structconvert(self, input_path, output_path):
        """
        Use structconvert to change file type.

        Parameters
        ----------
        input_path : :class:`str`
            The path to the input file.

        output_path : :class:`str`
            The path to the output file.

        Returns
        -------
        None : :class:`NoneType`

        """

        convrt_app = os.path.join(
            self._macromodel_path, 'utilities', 'structconvert'
        )
        convrt_cmd = [convrt_app, input_path, output_path]

        incomplete = True
        while incomplete:

            # Execute the file conversion.
            try:
                convrt_return = sp.run(
                    convrt_cmd,
                    stdout=sp.PIPE,
                    stderr=sp.STDOUT,
                    universal_newlines=True
                )

            # If conversion fails because a wrong Schrodinger path was
            # given, raise.
            except FileNotFoundError:
                raise MacroModelPathError(
                    'Wrong Schrodinger path supplied to structconvert.'
                )

            if 'File does not exist' in convrt_return.stdout:
                raise MacroModelConversionError(
                    f'structconvert input file, {input_path}, '
                    f'missing. Console output was '
                    f'{convrt_return.stdout}'
                )

            # Keep re-running the function until license is found.
            run_name, _ = os.path.splitext(input_path)
            if self._license_found(run_name, convrt_return.stdout):
                incomplete = False

        # If force field failed, raise.
        if 'number 1' in convrt_return.stdout:
            raise MacroModelForceFieldError(convrt_return.stdout)

        self._wait_for_file(output_path)
        if not os.path.exists(output_path):
            raise MacroModelConversionError(
                f'Conversion output file {output_path} was not found.'
                f' Console output was {convrt_return.stdout}.'
            )

        return convrt_return

    def _wait_for_file(self, path, timeout=10):
        """
        Wait until a given file exists or `timeout` expires.

        Parameters
        ----------
        path : :class:`str`
            The full path of the file which should be waited for.

        timeout : :class:`int` or :class:`float`, optional
            The number of seconds before the function stops waiting and
            returns.

        Returns
        --------
        None : :class:`NoneType`

        """

        t_start = time.time()
        tick = 0
        while True:
            time_taken = time.time() - t_start
            if divmod(time_taken, 5)[0] == tick + 1:
                logger.warning(f'Waiting for "{path}".')
                tick += 1

            if os.path.exists(path) or time_taken > timeout:
                break

    def _convert_maegz_to_mae(self, run_name):
        """
        Convert a ``.maegz`` file to a ``.mae`` file.

        Parameters
        ----------
        run_name : :class:`str`
            The name of the run. The files generated by this run will
            have this name.

        Returns
        -------
        None : :class:`NoneType`

        """

        gz_file = gzip.open(f'{run_name}-out.maegz')
        with open(f'{run_name}.mae', 'wb') as f:
            f.write(gz_file.read())
        gz_file.close()

    def _fix_params(self, mol, com):
        """
        Fix bond distances and angles in ``.com`` file.

        For each bond distance, bond angle and torsional angle that
        does not involve a bond created by
        :meth:`~.Topology.construct`, a "FX" command is added to the
        body of the ``.com`` file.

        These lines replace the filler line in the main string.

        Parameters
        ----------
        mol : :class:`stk.ConstructedMolecule`
            The molecule which is to be optimized.

        com : :class:`str`
            The body of the ``.com`` file which is to have fix commands
            added.

        Returns
        -------
        :class:`str`
            A string holding the body of the ``.com`` file with
            instructions to fix the various bond distances and angles
            as described in the docstring.

        """

        fix_block = ''
        # Add lines that fix the bond distance.
        fix_block = self._fix_distances(mol, fix_block)
        # Add lines that fix the bond angles.
        fix_block = self._fix_bond_angles(mol, fix_block)
        # Add lines that fix the torsional angles.
        fix_block = self._fix_torsional_angles(mol, fix_block)

        return com.replace(
            '!!!BLOCK_OF_FIXED_PARAMETERS_COMES_HERE!!!\n',
            fix_block
        )
